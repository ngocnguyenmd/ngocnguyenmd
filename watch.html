<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Xem phim</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<style>
  body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #1a191f;
  color: #fff;
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent;
}

/* HEADER */
header {
  background: #212026;
  padding: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  position: sticky;
  top: 0;
  z-index: 1000;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.Top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  max-width: 1000px;
}

.Logo {
  font-size: 20px;
  font-weight: 700;
  cursor: pointer;
  margin-bottom: 6px;
  transition: color 0.2s;
}
.Logo:hover { color: #de1212; }

.MenuBtn {
  font-size: 22px;
  cursor: pointer;
  padding: 8px;
  min-width: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.1);
  transition: background 0.2s;
}
.MenuBtn:hover { background: rgba(255, 255, 255, 0.2); }

.MenuDropdown {
  position: absolute;
  top: 100%;
  left: 0;
  width: 220px;
  background: #2b2b32;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  z-index: 1000;
  display: none;
  opacity: 0;
  transition: opacity 0.2s;
  max-height: 300px;
  overflow-y: auto;
}
.MenuBtn.active .MenuDropdown { display: block; opacity: 1; }

.MenuDropdown h3 {
  margin: 10px 0 5px 10px;
  font-size: 14px;
  border-bottom: 1px solid #444;
  padding-bottom: 5px;
  color: #bdbdbd;
}

.MenuDropdown button {
  display: block;
  width: 100%;
  margin: 5px 0;
  padding: 8px;
  border: none;
  background: #444;
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  text-align: left;
  transition: background 0.2s;
}
.MenuDropdown button:hover { background: #555; }

/* SEARCH */
.Search {
  display: flex;
  align-items: center;
  position: relative;
}
.Search input {
  width: 0;
  opacity: 0;
  transition: all 0.3s ease;
  padding: 8px;
  border: none;
  border-radius: 6px;
  outline: none;
  background: #2a292f;
  color: #fff;
  font-size: 14px;
}
.Search.active input {
  width: 180px;
  opacity: 1;
}
.Search button {
  margin-left: 8px;
  background: #de1212;
  border: none;
  padding: 8px 12px;
  color: #fff;
  cursor: pointer;
  border-radius: 6px;
  font-size: 14px;
  transition: background 0.2s;
}
.Search button:hover { background: #b00d0d; }

/* MAIN */
main {
  width: 100%;
  max-width: 1000px;  /* Gi·ªõi h·∫°n laptop */
  margin: 20px auto;
  padding: 0 10px;
  box-sizing: border-box;
}

.breadcrumbs {
  font-size: 14px;
  margin-bottom: 15px;
  color: #bdbdbd;
}
.breadcrumbs a {
  color: #de1212;
  text-decoration: none;
  transition: color 0.2s;
}
.breadcrumbs a:hover { color: #b00d0d; text-decoration: underline; }

.movie-info { margin-bottom: 20px; }
.movie-info h1 { font-size: 24px; margin: 0 0 10px; }
.movie-info p { font-size: 16px; color: #bdbdbd; }

/* PLAYER */
.player-container {
  width: 100%;
  max-width: 800px;     /* Kh√¥ng v∆∞·ª£t qu√° main */
  aspect-ratio: 16/9;    /* T·ªâ l·ªá chu·∫©n */
  margin: 0 auto 20px;
  background: #1f171700;
  border-radius: 10px;
  overflow: hidden;
  position: relative;
  box-sizing: border-box;
}

.player-container video,
.player-container iframe {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
  border-radius: 10px;
}

/* PLAYER CONTROLS */
.player-controls {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 10px 0;
}
.player-controls button {
  background: linear-gradient(145deg, #555, #333);
  color: #fff;
  border: none;
  padding: 10px 15px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
.player-controls button:hover {
  background: linear-gradient(145deg, #ff4d4d, #de1212);
  transform: scale(1.05);
}

/* SUBTITLE UPLOAD */
.subtitle-upload {
  margin: 10px 0;
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.subtitle-upload input[type="file"] { display: none; }
.subtitle-upload .upload-btn {
  background: linear-gradient(145deg, #de1212, #ff4d4d);
  color: #fff;
  border: none;
  padding: 10px 15px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  text-align: center;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
.subtitle-upload .upload-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 10px rgba(0,0,0,0.4);
}

/* STORY */
.story {
  margin: 20px 0;
  padding: 15px;
  background: #2b2b32;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}
.story h3 {
  font-size: 18px;
  margin: 0 0 10px;
  color: #fff;
}
.story p {
  font-size: 14px;
  color: #bdbdbd;
  line-height: 1.5;
}

/* CURRENT TIME */
.current-time {
  font-size: 14px;
  color: #bdbdbd;
  text-align: center;
  margin: 10px 0;
}

/* EPISODES */
.episodes h3 { font-size: 18px; margin: 20px 0 10px; color: #fff; }

.episode-section { margin-bottom: 20px; }
.episode-section .toggle-btn {
  background: linear-gradient(145deg, #555, #333);
  color: #fff;
  border: none;
  padding: 10px 15px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
  width: 100%;
  text-align: left;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
.episode-section .toggle-btn:hover {
  background: linear-gradient(145deg, #ff4d4d, #de1212);
}
.episode-section .toggle-btn .icon {
  font-size: 18px;
  transition: transform 0.3s ease;
}
.episode-section.open .toggle-btn .icon {
  transform: rotate(180deg);
}
.episode-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 10px;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}
.episode-section.open .episode-grid {
  max-height: 500px;
  padding-top: 10px;
}
.episode-grid button {
  background: linear-gradient(145deg, #555, #333);
  color: #fff;
  border: none;
  padding: 8px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  text-align: center;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
.episode-grid button:hover {
  background: linear-gradient(145deg, #ff4d4d, #de1212);
  transform: scale(1.05);
  box-shadow: 0 6px 10px rgba(0,0,0,0.4);
}
.episode-grid button.active {
  background: linear-gradient(145deg, #de1212, #ff4d4d);
  border: 2px solid #555;
  transform: scale(1.05);
  box-shadow: 0 6px 10px rgba(0,0,0,0.5);
}

/* RESPONSIVE */
@media (max-width: 1023px) {
  .Search.active input { width: 120px; }
  main { max-width: 95%; }
}
@media (max-width: 480px) {
  .Search.active input { width: 100px; }
  .movie-info h1 { font-size: 20px; }
  .movie-info p { font-size: 14px; }
  .episode-grid { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); }
  .player-controls button, .subtitle-upload .upload-btn {
    padding: 8px 12px; font-size: 12px;
  }
}
@media (max-width: 360px) {
  .episode-grid { grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); }
  .player-controls button, .subtitle-upload .upload-btn {
    padding: 6px 10px; font-size: 12px;
  }
}
</style>
</head>
<body>
  <header>
    <div class="Logo" onclick="location.href='index.html'">üé¨ B√°nh M√¨ üé¨</div>
    <div class="Top">
      <div class="MenuBtn" id="menuBtn">‚ò∞
        <div class="MenuDropdown">
          <!-- Menu dropdown c√≥ th·ªÉ th√™m n·ªôi dung t·ª´ index.html n·∫øu c·∫ßn -->
        </div>
      </div>
      <div class="Search" id="searchBox">
        <input id="searchInput" placeholder="Nh·∫≠p t√™n phim..." />
        <button id="searchBtn">T√¨m</button>
      </div>
    </div>
  </header>
  <main>
    <div class="breadcrumbs" id="breadcrumbs"></div>
    <div class="movie-info" id="movieInfo"></div>
    <div class="player-container" id="playerContainer"></div>
    <div class="player-controls" id="playerControls">
      <button id="prevEpisode">T·∫≠p tr∆∞·ªõc</button>
      <button id="rewind10s">Tua l·∫°i 10s</button>
      <button id="forward10s">Tua t·ªõi 10s</button>
      <button id="nextEpisode">T·∫≠p sau</button>
    </div>
    <div class="subtitle-upload" id="subtitleUpload">
      <label for="subtitleInput">T·∫£i l√™n ph·ª• ƒë·ªÅ (.srt, .vtt):</label>
      <input type="file" id="subtitleInput" accept=".srt,.vtt" />
      <button class="upload-btn" onclick="document.getElementById('subtitleInput').click()">T·∫£i l√™n ph·ª• ƒë·ªÅ</button>
    </div>
    <div class="current-time" id="currentTime"></div>
    <div class="episodes" id="episodes">
      <h3>Danh s√°ch t·∫≠p</h3>
      <div id="episodeList"></div>
    </div>
    <div class="story" id="story"></div>
  </main>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mediaelement/5.1.1/mediaelement-and-player.min.js"></script>
<script>
/* ==== FULL JS (Thay th·∫ø to√†n b·ªô script c≈©) ====
   - Gi·ªØ nguy√™n c·∫•u tr√∫c params, labels, UI logic
   - Player: Hls.js (fallback native HLS / fallback embed)
   - loadEpisodes: ph√¢n Vietsub / Thuy·∫øt minh / L·ªìng ti·∫øng, (A)/(B)
   - Subtitle upload: h·ªó tr·ª£ .srt /.vtt
   - Prev/Next, breadcrumbs, story, current time, search, menu
*/

  // Config sources v√† labels (gi·ªØ nguy√™n)
  const sources = [
    { name: "üçû B√°nh M√¨ 01", base: "https://ophim1.com/v1/api", type: "ophim" },
    { name: "üçû B√°nh M√¨ 02", base: "https://phimapi.com/v1/api", type: "phimapi" },
    { name: "üçû B√°nh M√¨ 03", base: "https://phim.nguonc.com/api", type: "nguonc" }
  ];

  const labels = {
    "hanh-dong": "H√†nh ƒê·ªông", "phieu-luu": "Phi√™u L∆∞u", "hoat-hinh": "Ho·∫°t H√¨nh", "hai": "H√†i",
    "hinh-su": "H√¨nh S·ª±", "tai-lieu": "T√†i Li·ªáu", "chinh-kich": "Ch√≠nh K·ªãch", "gia-dinh": "Gia ƒê√¨nh",
    "gia-tuong": "Gi·∫£ T∆∞·ªüng", "lich-su": "L·ªãch S·ª≠", "kinh-di": "Kinh D·ªã", "nhac": "Nh·∫°c",
    "bi-an": "B√≠ ·∫®n", "lang-man": "L√£ng M·∫°n", "khoa-hoc-vien-tuong": "Khoa H·ªçc Vi·ªÖn T∆∞·ªüng",
    "gay-can": "G√¢y C·∫•n", "chien-tranh": "Chi·∫øn Tranh", "tam-ly": "T√¢m L√Ω", "tinh-cam": "T√¨nh C·∫£m",
    "co-trang": "C·ªï Trang", "mien-tay": "Mi·ªÅn T√¢y", "phim-18": "Phim 18+",
    "au-my": "√Çu M·ªπ", "anh": "Anh", "trung-quoc": "Trung Qu·ªëc", "indonesia": "Indonesia",
    "viet-nam": "Vi·ªát Nam", "phap": "Ph√°p", "hong-kong": "H·ªìng K√¥ng", "han-quoc": "H√†n Qu·ªëc",
    "nhat-ban": "Nh·∫≠t B·∫£n", "thai-lan": "Th√°i Lan", "dai-loan": "ƒê√†i Loan", "nga": "Nga",
    "ha-lan": "H√† Lan", "philippines": "Philippines", "an-do": "·∫§n ƒê·ªô", "quoc-gia-khac": "Qu·ªëc gia kh√°c",
    "duc": "ƒê·ª©c", "tay-ban-nha": "T√¢y Ban Nha", "tho-nhi-ky": "Th·ªï Nhƒ© K·ª≥", "mexico": "Mexico",
    "ba-lan": "Ba Lan", "uc": "√öc", "thu·ªµ-den": "Th·ª•y ƒêi·ªÉn", "malaysia": "Malaysia",
    "brazil": "Brazil", "bo-dao-nha": "B·ªì ƒê√†o Nha", "y": "√ù", "dan-mach": "ƒêan M·∫°ch",
    "uae": "UAE", "na-uy": "Na Uy", "thu·ªµ-si": "Th·ª•y Sƒ©", "chau-phi": "Ch√¢u Phi",
    "nam-phi": "Nam Phi", "ukraina": "Ukraina", "a-rap-xe-ut": "·∫¢ R·∫≠p X√™ √öt", "bi": "B·ªâ",
    "ireland": "Ireland", "colombia": "Colombia", "phan-lan": "Ph·∫ßn Lan", "chile": "Chile",
    "hy-lap": "Hy L·∫°p", "nigeria": "Nigeria", "argentina": "Argentina", "singapore": "Singapore",
    "phim-moi": "Phim m·ªõi", "phim-bo": "Phim b·ªô", "phim-le": "Phim l·∫ª", "shows": "TV Shows",
    "hoat-hinh": "Ho·∫°t h√¨nh", "phim-vietsub": "Phim vietsub", "phim-thuyet-minh": "Phim thuy·∫øt minh",
    "phim-long-tieng": "Phim l·ªìng ti·∫øng", "phim-bo-dang-chieu": "Phim b·ªô ƒëang chi·∫øu",
    "phim-bo-da-hoan-thanh": "Phim b·ªô ƒë√£ ho√†n th√†nh", "phim-sap-chieu": "Phim s·∫Øp chi·∫øu",
    "subteam": "Subteam", "phim-chieu-rap": "Phim chi·∫øu r·∫°p"
  };
  const reverseLabels = Object.fromEntries(Object.entries(labels).map(([k, v]) => [v, k]));

  // Query params
  const params = new URLSearchParams(location.search);
  const slug = params.get("slug");
  const source = params.get("src") ? decodeURIComponent(params.get("src")) : null;
  const srcConf = sources.find(s => s.name === source);
  const ep = params.get("ep") ? decodeURIComponent(params.get("ep")) : null;
  let isEmbed = params.get("isEmbed") === "true";
  const epName = params.get("epName") || "T·∫≠p ƒëang xem";
  const name = params.get("name") ? decodeURIComponent(params.get("name")) : "";
  const category = params.get("category") || "";
  const region = params.get("region") || "";
  const year = params.get("year") || "";
  const type = params.get("type") || "";
  const search = params.get("search") || "";

  if (srcConf?.type === 'nguonc') isEmbed = true;

  // DOM refs
  const playerContainer = document.getElementById("playerContainer");
  const movieInfo = document.getElementById("movieInfo");
  const breadcrumbs = document.getElementById("breadcrumbs");
  const episodeList = document.getElementById("episodeList");
  const subtitleUpload = document.getElementById("subtitleUpload");
  const subtitleInput = document.getElementById("subtitleInput");
  const playerControls = document.getElementById("playerControls");
  const prevEpisodeBtn = document.getElementById("prevEpisode");
  const nextEpisodeBtn = document.getElementById("nextEpisode");
  const rewind10sBtn = document.getElementById("rewind10s");
  const forward10sBtn = document.getElementById("forward10s");
  const story = document.getElementById("story");
  const currentTime = document.getElementById("currentTime");
  const searchBox = document.getElementById("searchBox");
  const searchInput = document.getElementById("searchInput");
  const searchBtn = document.getElementById("searchBtn");
  const menuBtn = document.getElementById("menuBtn");

  // Episode navigation state
  let currentEpisodeIndex = -1;
  let allEpisodes = [];

  // Helpers
  function slugify(text) {
    if (!text) return "";
    return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/ƒë/g, "d").replace(/ƒê/g, "D").replace(/[^a-z0-9\s-]/g, "").trim().replace(/\s+/g, "-");
  }

  function fixImagePath(img, src) {
    if (!img) return "";
    if (img.startsWith("http")) return img;
    if (src.type === "ophim") return `https://img.ophim.live/uploads/movies${img.startsWith("/") ? img : "/" + img}`;
    if (src.type === "phimapi") return `https://phimimg.com${img.startsWith("/") ? img : "/" + img}`;
    if (src.type === "nguonc") return img;
    return img.startsWith("/") ? img : "/" + img;
  }

  async function tryUrls(urls) {
    for (const u of urls) {
      try {
        const res = await fetch(u);
        if (!res.ok) {
          console.warn(`Failed to fetch ${u}: ${res.status}`);
          continue;
        }
        const json = await res.json();
        if (json.status === false) {
          console.warn(`API error at ${u}: ${json.msg}`);
          continue;
        }
        if (json.data?.item || json.movie || json.data) return { url: u, data: json };
      } catch (e) {
        console.warn(`Error fetching ${u}:`, e);
      }
    }
    console.warn("No valid response from any URL");
    return null;
  }

  async function fetchEpisodes(slug, srcConf) {
    const epUrl = srcConf.type === "nguonc" ? `${srcConf.base}/film/${slug}/episodes` : `${srcConf.base}/phim/${slug}/episodes`;
    try {
      const res = await fetch(epUrl);
      if (!res.ok) {
        console.warn(`Failed to fetch episodes from ${epUrl}: ${res.status}`);
        return [];
      }
      const json = await res.json();
      if (json.status === false) {
        console.warn(`Episodes API error at ${epUrl}: ${json.msg}`);
        return [];
      }
      return json.episodes || json.data?.episodes || [];
    } catch (e) {
      console.warn(`Error fetching episodes from ${epUrl}:`, e);
      return [];
    }
  }

  // Convert SRT to VTT
  function convertSrtToVtt(srtContent) {
    try {
      srtContent = srtContent.replace(/^\uFEFF/, '');
      let vtt = 'WEBVTT\n\n' + srtContent
        .replace(/(\d{2}:\d{2}:\d{2}),(\d{3})/g, '$1.$2')
        .replace(/^\d+$/gm, (match) => `${match}\n`)
        .replace(/\r\n|\r|\n/g, '\n');
      return vtt;
    } catch (e) {
      console.warn("Error converting SRT to VTT:", e);
      return null;
    }
  }

  /* ---------- PLAYER (Hls.js) ---------- */
  let hls, video;
  async function loadPlayer() {
    // Guard
    if (!ep || !srcConf) {
      playerContainer.innerHTML = "<p>Kh√¥ng t√¨m th·∫•y link video ho·∫∑c ngu·ªìn kh√¥ng h·ª£p l·ªá.</p>";
      subtitleUpload.style.display = "none";
      playerControls.style.display = "none";
      return;
    }

    // If embed mode -> iframe
    if (isEmbed) {
      playerContainer.innerHTML = `<iframe src="${ep}" allowfullscreen allow="autoplay"></iframe>`;
      subtitleUpload.style.display = "none";
      playerControls.style.display = "none";
      return;
    }

    // Create <video>
    playerContainer.innerHTML = `<video id="videoPlayer" playsinline controls preload="auto" style="width:100%;max-height:70vh;background:#000"></video>`;
    video = document.getElementById("videoPlayer");

    // Native HLS (Safari)
    if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = ep;
      video.addEventListener('loadedmetadata', () => {
        video.play().catch(e => console.warn("Play error (native):", e));
      });
    }
    // Use Hls.js if available
    else if (typeof Hls !== 'undefined' && Hls.isSupported()) {
      hls = new Hls({
        autoStartLoad: true,
        startFragPrefetch: true,
        maxBufferLength: 60,
        maxMaxBufferLength: 120,
        liveSyncDuration: 3
      });
      hls.loadSource(ep);
      hls.attachMedia(video);

      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        // Auto-play when manifest parsed
        video.play().catch(e => console.warn("Play error (hls):", e));
      });

      hls.on(Hls.Events.ERROR, (event, data) => {
        console.warn("Hls.js error:", data);
        if (data && data.fatal) {
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.log("Hls network error, trying to startLoad()");
              try { hls.startLoad(); } catch (e) { console.warn(e); }
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.log("Hls media error, trying recoverMediaError()");
              try { hls.recoverMediaError(); } catch (e) { console.warn(e); }
              break;
            default:
              console.log("Hls fatal error -> fallback to embed");
              try { hls.destroy(); } catch (e) {}
              fallbackToEmbed();
              break;
          }
        }
      });
    } else {
      // No Hls support
      playerContainer.innerHTML = "<p>Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ HLS</p>";
      subtitleUpload.style.display = "none";
      playerControls.style.display = "none";
      return;
    }

    // Show controls and subtitle box
    subtitleUpload.style.display = "flex";
    playerControls.style.display = "flex";

    // Rewind / forward
    rewind10sBtn.onclick = () => {
      if (!video) return;
      try { video.currentTime = Math.max(0, video.currentTime - 10); } catch (e) { console.warn(e); }
    };
    forward10sBtn.onclick = () => {
      if (!video) return;
      try { video.currentTime = Math.min(video.duration || Infinity, video.currentTime + 10); } catch (e) { console.warn(e); }
    };

    // When page unload / navigate, clean hls to avoid console errors
    window.addEventListener('beforeunload', () => { try { if (hls) hls.destroy(); } catch(e){} });
  }

  // Fallback: try to find embed links and switch to iframe
  async function fallbackToEmbed() {
    playerContainer.innerHTML = "<p>L·ªói khi t·∫£i video M3U8, ƒëang th·ª≠ chuy·ªÉn sang embed...</p>";
    const episodes = await fetchEpisodes(slug, srcConf);
    const embedLink = episodes.flatMap(s => (s.items || s.server_data || s.episodes || []).map(e => e.embed || e.link_embed)).find(Boolean);
    if (embedLink) {
      playerContainer.innerHTML = `<iframe src="${embedLink}" allowfullscreen allow="autoplay"></iframe>`;
      subtitleUpload.style.display = "none";
      playerControls.style.display = "none";
      isEmbed = true;
    } else {
      playerContainer.innerHTML = "<p>Kh√¥ng th·ªÉ t·∫£i video. Vui l√≤ng ch·ªçn t·∫≠p kh√°c.</p>";
    }
  }

  /* ---------- Subtitle Upload ---------- */
  subtitleInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file || !/\.(srt|vtt)$/i.test(file.name)) {
      alert("Vui l√≤ng ch·ªçn file ph·ª• ƒë·ªÅ ƒë·ªãnh d·∫°ng .srt ho·∫∑c .vtt");
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      let content = event.target.result;
      if (file.name.endsWith('.srt')) {
        content = convertSrtToVtt(content);
        if (!content) { alert("L·ªói khi chuy·ªÉn SRT -> VTT"); return; }
      }
      const subtitleBlob = new Blob([content], { type: 'text/vtt' });
      const subtitleUrl = URL.createObjectURL(subtitleBlob);

      if (video && !isEmbed) {
        // Remove existing tracks
        const tracks = video.getElementsByTagName('track');
        while (tracks.length > 0) video.removeChild(tracks[0]);

        const track = document.createElement('track');
        track.kind = 'subtitles';
        track.label = 'Ph·ª• ƒë·ªÅ t·∫£i l√™n';
        track.srclang = 'vi';
        track.src = subtitleUrl;
        track.default = true;
        video.appendChild(track);

        // Try to enable it
        setTimeout(() => {
          try {
            for (let i = 0; i < video.textTracks.length; i++) {
              const tt = video.textTracks[i];
              if (tt.language === 'vi' || tt.label === 'Ph·ª• ƒë·ªÅ t·∫£i l√™n') tt.mode = 'showing';
            }
          } catch (e) { console.warn("Kh√¥ng b·∫≠t ƒë∆∞·ª£c ph·ª• ƒë·ªÅ t·ª± ƒë·ªông:", e); }
        }, 200);
      } else {
        alert("Kh√¥ng th·ªÉ t·∫£i ph·ª• ƒë·ªÅ v√¨ video ch∆∞a s·∫µn s√†ng ho·∫∑c ƒëang ·ªü ch·∫ø ƒë·ªô embed.");
      }
    };
    reader.onerror = () => alert("L·ªói khi ƒë·ªçc file ph·ª• ƒë·ªÅ. Vui l√≤ng th·ª≠ l·∫°i.");
    reader.readAsText(file, 'UTF-8');
  });

  /* ---------- Movie info / story / breadcrumbs / time ---------- */
  function loadMovieInfo(isVietsub) {
    const suffix = isVietsub ? " Vietsub" : "";
    movieInfo.innerHTML = `<h1>${name || "Phim"}</h1><p>T·∫≠p ƒëang xem: ${epName}${suffix}</p>`;
  }

  async function loadStory() {
    if (!slug || !srcConf) {
      story.innerHTML = `<h3>C·ªët truy·ªán</h3><p>Kh√¥ng c√≥ th√¥ng tin c·ªët truy·ªán.</p>`;
      return;
    }
    const url = srcConf.type === "nguonc" ? `${srcConf.base}/film/${slug}` : `${srcConf.base}/phim/${slug}`;
    const res = await tryUrls([url]);
    if (!res) {
      story.innerHTML = `<h3>C·ªët truy·ªán</h3><p>Kh√¥ng th·ªÉ t·∫£i th√¥ng tin c·ªët truy·ªán. Vui l√≤ng th·ª≠ l·∫°i sau.</p>`;
      return;
    }
    const data = res.data;
    const item = data.data?.item || data.movie || data.data || {};
    const description = item.description || item.content || item.overview || "Kh√¥ng c√≥ th√¥ng tin c·ªët truy·ªán.";
    story.innerHTML = `<h3>C·ªët truy·ªán</h3><p>${description}</p>`;
  }

  function updateCurrentTime() {
    const now = new Date();
    const formatted = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth()+1).toString().padStart(2,'0')}/${now.getFullYear()} ${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}:${now.getSeconds().toString().padStart(2,'0')}`;
    currentTime.textContent = `Th·ªùi gian hi·ªán t·∫°i: ${formatted}`;
    setTimeout(updateCurrentTime, 1000);
  }

  function loadBreadcrumbs() {
    const catSlug = category || "";
    const countrySlug = region || "";
    breadcrumbs.innerHTML = `
      <a href="index.html"> Trang ch·ªß</a> > 
      ${catSlug ? `<a href="index.html?category=${catSlug}">${labels[catSlug] || catSlug}</a> > ` : ""}
      ${countrySlug ? `<a href="index.html?region=${countrySlug}">${labels[countrySlug] || countrySlug}</a> > ` : ""}
      ${year ? `<a href="index.html?year=${year}">${year}</a> > ` : ""}
      <a href="detail.html?slug=${encodeURIComponent(slug)}&src=${encodeURIComponent(source)}${category ? '&category=' + encodeURIComponent(category) : ''}${region ? '&region=' + encodeURIComponent(region) : ''}${year ? '&year=' + encodeURIComponent(year) : ''}${type ? '&type=' + encodeURIComponent(type) : ''}${search ? '&search=' + encodeURIComponent(search) : ''}">${name || "Phim"}</a> > Xem
    `;
  }

  /* ---------- Episodes (chi ti·∫øt: Vietsub / TM / LT; (A)/(B)) ---------- */
  function normalizeServersFromItem(item) {
    // Return array of server objects: { server_name, items: [...] }
    if (!item) return [];
    // Candidates to inspect
    const candidates = [ item.episodes, item.episode, item.data?.episodes, item.server_data, item.servers ];
    for (const c of candidates) {
      if (!c) continue;
      if (Array.isArray(c)) {
        // If array seems to be array of servers (having server_name or items)
        if (c.length && (c[0].server_name || c[0].items || c[0].server_data)) {
          return c.map(s => ({ server_name: s.server_name || s.name || 'Server', items: s.items || s.server_data || s.episodes || [] }));
        }
        // Otherwise array of episodes -> wrap into single server
        return [{ server_name: 'Server', items: c }];
      } else if (typeof c === 'object') {
        // object of server arrays
        const arr = Object.entries(c).map(([k, v]) => ({ server_name: k, items: Array.isArray(v) ? v : (v.items || v.server_data || []) }));
        if (arr.length) return arr;
      }
    }

    // Last resort: try item.servers or convert item.episodes object values
    if (item.episodes && typeof item.episodes === 'object') {
      const values = Object.values(item.episodes).filter(Boolean);
      if (values.length) {
        // if each value is an array of episodes
        if (Array.isArray(values[0])) {
          return values.map((arr, idx) => ({ server_name: `Server ${idx+1}`, items: arr }));
        } else {
          // map each val to server object if shape matches
          return values.map(v => ({ server_name: v.server_name || 'Server', items: v.items || v.server_data || (Array.isArray(v) ? v : []) }));
        }
      }
    }

    return [];
  }

  async function loadEpisodes() {
    if (!slug || !srcConf) {
      episodeList.innerHTML = "<p>Kh√¥ng t√¨m th·∫•y phim ho·∫∑c ngu·ªìn kh√¥ng h·ª£p l·ªá.</p>";
      return;
    }

    const url = srcConf.type === "nguonc" ? `${srcConf.base}/film/${slug}` : `${srcConf.base}/phim/${slug}`;
    const res = await tryUrls([url]);
    let servers = [];

    if (!res) {
      console.warn(`Main API failed for ${url}, trying episodes endpoint`);
      const eps = await fetchEpisodes(slug, srcConf);
      // eps may already be servers array or episodes list
      if (eps && Array.isArray(eps) && eps.length && (eps[0].server_name || eps[0].items || eps[0].server_data)) {
        servers = eps.map(s => ({ server_name: s.server_name || s.name || 'Server', items: s.items || s.server_data || s.episodes || [] }));
      } else {
        // wrap into single server
        servers = [{ server_name: 'Server', items: eps }];
      }
    } else {
      const data = res.data;
      const item = data.data?.item || data.movie || data.data || {};
      servers = normalizeServersFromItem(item);
      if (!servers.length) {
        // fallback to episodes endpoint
        const eps2 = await fetchEpisodes(slug, srcConf);
        if (eps2 && eps2.length) {
          servers = eps2.map(s => ({ server_name: s.server_name || s.name || 'Server', items: s.items || s.server_data || s.episodes || [] }));
        }
      }
    }

    // If still empty
    if (!servers || servers.length === 0) {
      episodeList.innerHTML = "<p>Phim hi·ªán ch∆∞a c√≥ t·∫≠p n√†o ho·∫∑c API kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i sau.</p>";
      return;
    }

    // Build UI: Vietsub / Thuyet Minh / Long Tieng groups
    allEpisodes = [];
    episodeList.innerHTML = "";
    const vsDiv = document.createElement("div"); vsDiv.className = "episode-section open";
    const vsToggle = document.createElement("button"); vsToggle.className = "toggle-btn"; vsToggle.innerHTML = 'Vietsub <span class="icon">V</span>'; vsDiv.appendChild(vsToggle);
    const vsGrid = document.createElement("div"); vsGrid.className = "episode-grid"; vsDiv.appendChild(vsGrid);

    const tmDiv = document.createElement("div"); tmDiv.className = "episode-section";
    const tmToggle = document.createElement("button"); tmToggle.className = "toggle-btn"; tmToggle.innerHTML = 'Thuy·∫øt Minh <span class="icon">V</span>'; tmDiv.appendChild(tmToggle);
    const tmGrid = document.createElement("div"); tmGrid.className = "episode-grid"; tmDiv.appendChild(tmGrid);

    const ltDiv = document.createElement("div"); ltDiv.className = "episode-section";
    const ltToggle = document.createElement("button"); ltToggle.className = "toggle-btn"; ltToggle.innerHTML = 'L·ªìng Ti·∫øng <span class="icon">V</span>'; ltDiv.appendChild(ltToggle);
    const ltGrid = document.createElement("div"); ltGrid.className = "episode-grid"; ltDiv.appendChild(ltGrid);

    [vsToggle, tmToggle, ltToggle].forEach(toggle => {
      toggle.addEventListener('click', () => {
        const section = toggle.parentElement;
        section.classList.toggle('open');
        const icon = toggle.querySelector('.icon');
        icon.textContent = section.classList.contains('open') ? 'V' : '^';
      });
    });

    let isVietsub = false;

    servers.forEach((server, serverIdx) => {
      const serverName = server.server_name || server.name || `Server ${serverIdx + 1}`;
      let languageType = 'vs';
      if (/thuy·∫øt minh|thuyet|tm/i.test(serverName) || (server.language && /thuy·∫øt minh|thuyet|tm/i.test(server.language))) languageType = 'tm';
      else if (/l·ªìng ti·∫øng|long tieng|lt/i.test(serverName) || (server.language && /l·ªìng ti·∫øng|long tieng|lt/i.test(server.language))) languageType = 'lt';
      else isVietsub = true;

      const serverData = server.items || server.server_data || server.episodes || [];
      const grid = languageType === 'tm' ? tmGrid : languageType === 'lt' ? ltGrid : vsGrid;

      serverData.forEach((epItem, idx) => {
        const m3u8 = epItem.link_m3u8 || epItem.link || epItem.m3u8 || epItem.file || "";
        const embed = epItem.embed || epItem.link_embed || "";
        const currEpName = epItem.name || epItem.title || epItem.slug || `T·∫≠p ${idx + 1}`;
        const queryParams = new URLSearchParams({ slug, src: source, name: name || '', category, region, year, type, search, epName: currEpName });

        // If m3u8 and not nguonc -> (A)
        if (m3u8 && srcConf.type !== "nguonc") {
          queryParams.set('ep', m3u8);
          queryParams.set('isEmbed', false);
          const btn = document.createElement("button");
          btn.textContent = `${currEpName} (A)`;
          btn.onclick = () => location.href = `watch.html?${queryParams.toString()}`;
          if (currEpName === epName || m3u8 === ep) {
            btn.classList.add("active");
            currentEpisodeIndex = allEpisodes.length;
          }
          grid.appendChild(btn);
          allEpisodes.push({ url: `watch.html?${queryParams.toString()}`, name: currEpName });
        }

        // If embed (nguonc) -> (B)
        if (embed && srcConf.type === "nguonc") {
          queryParams.set('ep', embed);
          queryParams.set('isEmbed', true);
          const btn = document.createElement("button");
          btn.textContent = `${currEpName} (B)`;
          btn.onclick = () => location.href = `watch.html?${queryParams.toString()}`;
          if (currEpName === epName || embed === ep) {
            btn.classList.add("active");
            currentEpisodeIndex = allEpisodes.length;
          }
          grid.appendChild(btn);
          allEpisodes.push({ url: `watch.html?${queryParams.toString()}`, name: currEpName });
        }
      });
    });

    if (vsGrid.children.length > 0) episodeList.appendChild(vsDiv);
    if (tmGrid.children.length > 0) episodeList.appendChild(tmDiv);
    if (ltGrid.children.length > 0) episodeList.appendChild(ltDiv);
    if (episodeList.children.length === 0) episodeList.innerHTML = "<p>Phim hi·ªán ch∆∞a c√≥ t·∫≠p n√†o ho·∫∑c API kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i sau.</p>";

    // Update movie info
    loadMovieInfo(isVietsub);

    // Episode navigation (prev/next)
    prevEpisodeBtn.onclick = () => {
      if (currentEpisodeIndex > 0) {
        location.href = allEpisodes[currentEpisodeIndex - 1].url;
      }
    };
    nextEpisodeBtn.onclick = () => {
      if (currentEpisodeIndex < allEpisodes.length - 1) {
        location.href = allEpisodes[currentEpisodeIndex + 1].url;
      }
    };
    prevEpisodeBtn.disabled = currentEpisodeIndex <= 0;
    nextEpisodeBtn.disabled = currentEpisodeIndex >= allEpisodes.length - 1;
  }

  // Search v√† menu handlers
  searchBtn.addEventListener("click", () => {
    const q = searchInput.value.trim();
    if (!q) return searchBox.classList.toggle("active"), searchInput.focus();
    location.href = `index.html?search=${encodeURIComponent(q)}`;
  });
  searchInput.addEventListener("keydown", (e) => e.key === "Enter" && searchBtn.click());
  menuBtn.addEventListener("click", (e) => { e.stopPropagation(); menuBtn.classList.toggle("active"); });
  document.addEventListener("click", () => menuBtn.classList.remove("active"));

  // Load on DOM content loaded
  window.addEventListener("DOMContentLoaded", () => {
    loadPlayer();
    loadBreadcrumbs();
    loadEpisodes();
    loadStory();
    updateCurrentTime();
  });
</script>

</body>
</html>